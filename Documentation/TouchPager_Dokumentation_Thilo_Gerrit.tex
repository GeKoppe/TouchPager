\documentclass[a4paper, 11pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}

\usepackage{mathptmx}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[left=2.5cm, right=2.5cm, top=2.5cm, bottom=2cm]{geometry}
\usepackage[singlespacing]{setspace}

% \usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{floatflt,epsfig}
\usepackage{scrlayer-scrpage}
\usepackage{hyperref}
\usepackage{float}
\usepackage{sectsty}

\usepackage{xcolor}
\usepackage{floatflt,epsfig}
% \usepackage[fleqn]{amsmath}
\usepackage{listings}
\usepackage{color}
%\usepackage{minted}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{language=C++,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{mauve},
commentstyle=\color{dkgreen},
stringstyle=\color{blue},
breaklines=true,
breakatwhitespace=true,
tabsize=3,
    morekeywords={
        Messenger,Elegoo_TFTLCD,TouchScreen,VKeys,ScreenParse,int,TSPoint,String,ColorChooser,
        ColorChoser,Radio % TODO hier müssen noch die restlichen Keywords eingepflegt werden
    }
}

\definecolor{BBS}{RGB}{0,169,164}

\sectionfont{\color{BBS}}
\subsectionfont{\color{BBS}}
\subsubsectionfont{\color{BBS}}

\begin{document}
\thispagestyle{empty}
\ihead{
    \begin{footnotesize}
        Dokumentation Arduino Pager
    \end{footnotesize}
}
\chead{
    \begin{footnotesize}
        Lernfeld 7: Cyberphysische Systeme ergänzen
    \end{footnotesize}
}
\ohead{
    \begin{footnotesize}
        Thilo Drehlmann, Gerrit Koppe
    \end{footnotesize}
}
\vspace{0.2\textheight}
\begin{center}
    \begin{figure}[H]
        \begin{minipage}{0.3\textwidth}
            \includegraphics[scale=0.6]{Bilder/BBS}
        \end{minipage}
        \hspace{0.48\textwidth}
        \begin{minipage}{0.3\textwidth}
            \includegraphics[scale=0.6]{Bilder/sievers.png}
        \end{minipage}
    \end{figure}
    \vspace{1cm}
    \begin{Huge}
        \textcolor{BBS}{\textbf{Dokumentation Arduino Pager}} 
    \end{Huge}
    \\
    \vspace{0.1\textheight}
    \begin{Large}
        Autoren: Thilo Drehlmann, Gerrit Koppe
    \end{Large}
    \\
    \vspace{0.5cm}
    \begin{Large}
        Ausbildungsberuf: Fachinformatiker für Anwendungsentwicklung
    \end{Large}
    \\
    \vspace{0.5cm}
    \begin{Large}
        \today
    \end{Large}
\end{center}
\newpage
\thispagestyle{empty}
\tableofcontents
\newpage
\clearpage
\pagenumbering{arabic}
\section{Einleitung}
In dieser Dokumentation wird die Umsetzung eines bidirektionalen Pagers auf Basis der Arduino Plattform beschrieben. Zunächst werden Thema und Ziel des Projekts formuliert.
Anschließend wird auf die Planung der Ressourcen und des Ablaufs, sowie auf die benötigten Komponenten eingegangen. Im Anschluss wird das Vorgehen während des Projektes dokumentiert
und abschließend das Ergebnis der Durchführung präsentiert.

\section{Formulierung des Themas}
\subsection{Beschreibung des Projektes}
Das Thema des Projektes ist es, eine bidirektionale Kommunikation zwischen zwei Geräten auf Arduino-Basis zu gewährleisten. Es soll die Möglichkeit bestehen,
Nachrichten zu verfassen, zu versenden und ebenso Nachrichten zu empfangen, die von einem anderen Arduino Gerät versendet wurden.

\subsection{Definition der Ziele, erwartetes Ergebnis}
Im Folgenden werden die allgemein Ziele des Projektes näher definiert.
\\
\\
1. Es soll möglich sein, mittels eines Touchscreens und einer virtuellen Tastatur, Zeichenketten auf einem, an den Arduino angeschlossenen Touchscreen, zu schreiben.
\\
2. Die eingegebenen Zeichenketten sollen, mittels Funkwellen, an ein anderes Gerät übertragen werden können.
\\
3. Das Gerät soll in der Lage sein, Funkwellen zu empfangen.
\\
4. Das Gerät soll außerdem in der Lage sein, die empfangenen Funkwellen wieder zu einer Zeichenkette zu übersetzen und auf einem Touchscreen anzuzeigen.
\\
5. Es soll ein graphisches User Interface auf dem Touchscreen geben.
\\
6. Es soll möglich sein, empfangene Nachrichten zwischenzuspeichern, damit neu empfangene Nachrichten nicht die vorherigen Nachrichten überschreiben.
\\
7. Es soll möglich sein, den Zwischenspeicher der Nachrichten über einen eigenen Menüpunkt abzurufen und die empfangenen Nachrichten zu verwalten.
\\
\\
Außerdem gibt es folgende, optionale Ziele:
\\
\\
a. Das User Interface soll farblich angepasst werden können.
\\
b. Es soll möglich sein, zu überprüfen, ob empfangsbereite Geräte in der Nähe sind.


\section{Ressourcen und Ablaufplanung}
\subsection{Allgemeine und Ressourcenplanung}\label{ch:planning}
Das Projekt besteht aus zwei Teilen, der drahtlosen Kommunikation zweier Arduino Geräte miteinander und dem User Interface / der menschlichen Schnittstelle mit der
Hardware, über die Nachrichten angezeigt, aber auch eingegeben und versendet werden können. Für die Planung ist also zunächst relevant, welche Hardware Komponenten benötigt werden, 
um beide Projektteile umzusetzen.
\\
Für die drahtlose Kommunikation kann auf verschiedene Technologien wie Bluetooth oder Radio-Frequenz zurückgegriffen werden. Da Bluetooth nur eine sehr eingeschränkte
Reichweite besitzt und eine Kopplung der Geräte notwendig ist, haben wir uns dafür entschieden, die drahtlose Übertragung per Radiofrequenz durchzuführen. Außerdem existieren
für eine solche Übertragung kostengünstige Hardware und fertige API-Bibliotheken für die Hardware. Aus diesen Gründen wurde sich für die nRF24L01+ Transceiver 
(im Folgenden als \glqq Antenne\grqq{} oder \glqq Transceiver\grqq{} bezeichnet) entschieden.\footnote{Vgl. Hardware Link~\ref{itm:transceiverlink}}
\\
Für die Umsetzung der menschlichen Schnittstelle sollten zunächst ein Numpad, sowie ein 16x2 Liquid Crystal Display verwendet werden. Aufgrund der stark eingeschränkten Nutzbarkeit des LCD,
sowie umständlicher Eingabe über das Numpad, wurde sich stattdessen entschieden, einen Touchscreen zu verwenden. Da bereits Arduino Uno R3 Boards der Marke Elegoo zur Verfügung standen,
wurde sich hier für den Elegoo TFT 2,8'' Touchscreen (im Folgenden als \glqq TFT\grqq{} oder \glqq Touchschreen\grqq{} bezeichnet) entschieden.\footnote{Vgl. Hardware Link~\ref{itm:tftlink}} Dieser
hat außerdem den Vorteil, dass Elegoo Bibliotheken mitliefert, um den Touchscreen zu programmieren.
\\
Schlussendlich musste noch entschieden werden, welches Arduino Board verwendet werden sollte. Aufgrund guter Erfahrung mit der Marke Elegoo in Hinsicht auf Zuverlässigkeit und Nutzbarkeit, wurde sich für
ebenjene Marke entschieden. Da der Touchscreen als Shield\footnote{Vgl. Glossar~\ref{def:shield}: Shield} für Arduino Uno Boards konzipiert ist, wäre es bei einem Arduino Uno nicht mehr möglich,
weitere Hardware Komponenten anzuschließen. Entsprechend fiel die Entscheidung auf den Elegoo Arduino Mega R3\footnote{Vgl. Hardware Link~\ref{itm:arduinolink}}, da dieser deutlich mehr Pinouts zur Verfügung
stellt, als ein Arduino Uno. Weitere Gründe für diese Entscheidung sind, dass der Transceiver über den SPI Bus des Arduinos kommuniziert, dieser wäre bei einem Arduino Uno aber durch den TFT blockiert. Außerdem
wird viel Quellcode erwartet, was bedeutet, dass der Programmierspeicher des Arduino Uno zu klein sein könnte, auch hier hat der Arduino Mega mehr Ressourcen.

\subsection{Ressourcen}

\subsubsection{Benötigte Hardware}
In Anhang Tabelle~\ref{tab:hardware} findet sich eine detaillierte, tabellarische Auflistung aller in Kapitel~\ref{ch:planning} genannten Komponenten, ihrer Aufgaben und ihrer Preise.
Alle Komponenten werden zwei mal benötigt, da eine Kommunikation zwischen zwei identischen Geräten hergestellt werden soll.

\subsubsection{Benötigte Software}
Zur Umsetzung des Projekts wird, um die Programmierung zu vereinfachen und den Quellcode schlanker zu halten, auf verschiedene externe Bibliotheken zurückgegriffen.
Eine detaillierte Auflistung dieser Bibliotheken findet sich im Anhang Tabelle~\ref{tab:software}.

\subsection{Planung der Umsetzung}
Um das Projekt sinnvoll zu strukturieren, wurden zunächst Teilziele definiert, die nacheinander umgesetzt werden sollen.
\\
Als erstes sollen grundlegende Funktionalitäten entwickelt werden, wie zum Beispiel das  

\subsubsection{Teilziele}
\begin{enumerate}
    \item \textit{Vordefinierte Nachricht unidirektional übertragen}: Zunächst soll eine statisch eingestellte Nachricht zwischen zwei Arduino Mega mittels nRF24L01+ Transceiver
            Übertragen werden können, um zu prüfen, ob die Verbindung hergestellt werden kann.
    \item 
\end{enumerate}

\subsubsection{Erwartete Schwierigkeiten}
Im Folgenden werden alle Schwierigkeiten aufgelistet und erklärt, die während der Umsetzung des Projekts erwartet werden.
\begin{enumerate}
    \item \textit{Fehlersuche bei fehlerhafter Übertragung}: Da dieses Projekt darauf basiert, Funksignale zu versenden und zu empfangen und die Umsetzenden keine Gerätschaft
            besitzen, Funkwellen und Signalstärken dieser zu messen, wird es schwierig, den Fehler zu identifizieren, sollte eine Übertragung fehlschlagen.
    \item \textit{Distanzregulierung}: Die Transceiver können in verschiedenen Signalstärken senden, die programmatisch eingestellt werden müssen.
            Wird eine zu hohe Signalstärke konfiguriert, leidet darunter allerdings die Übertragungsqualität bei niedrigen Distanzen. Hier muss ein gutes Mittelmaß
            gefunden werden.
    \item \textit{Wechsel zwischen Empfang und Senden}: Da die Nachrichten bidirektional versendet werden sollen, die Transceiver aber nur halbduplex arbeiten,
            muss ein rechtzeitiger Wechsel der Antenne zwischen Senden und Empfang garantiert werden. Sollten beide Geräte gleichzeitig Senden, werden beide Nachrichten
            verloren gehen.
    \item \textit{Empfang garantieren}: Da die Möglichkeit bestehen soll, gleich 
    \item \textit{Kein Multithreading}: Da Arduinos nicht Multithreading-fähig\footnote{vgl. Glossar~\ref{def:multithreading}: Multithreading} sind, wird eine Schwierigkeit
            darin bestehen, permanent gleichzeitig die Nutzung des Geräts und den Empfang eingehender Nachrichten zu gewährleisten.
\end{enumerate}

\subsubsection{Zeitliche Planung}
Ein Netzplan mit detaillierter Zeitplanung findet sich im Kapitel~\ref{ch:diags} Abbildung~\ref{diag:netzplan}. Der Plan lässt sich weiterhin unterteilen in die
Planungsphase (Schritte 1-6) und die Umsetzungsphase (alle weiteren Schritte), abgebildet in Kapitel~\ref{ch:diags} Abbildung~\ref{diag:netzplan_planung} 
und Abbildung~\ref{diag:netzplan_umsetzung}.
\\
Da vor der Umsetzung des Projekts keine Erfahrung im Umgang mit der Arduino Plattform bestand, wurden bei der Planung der gesamten Planungsphase (Netzplan Schritte 1-6) 
viel Zeit eingeräumt, durch die fehlendes Wissen und Einarbeitung kompensiert werden sollten. Des Weiteren wurden 6, respektive 8 Stunden geplant, damit die 
Umsetzenden sich mit den einzelnen Komponenten vertraut machen konnten (Netzplan Schritte 4 und 5). Nach erfolgreicher Einarbeitung wurden weitere 2 Stunden
für die Konzeptionierung des Quellcodes eingeplant\footnote{Ergebnis abgebildet in Kapitel~\ref{ch:diags} Abbildung~\ref{diag:classdiag}.}. Die zeitliche 
Planung der Umsetzung wurde erst nach der Planungsphase durchgeführt, da diese abhängig vom, in der Planung entstandenen, Design des Quellcodes war.\footnote{Alle bis hier 
beschriebenen Schritte sind in Kapitel~\ref{ch:diags} Abbildung~\ref{diag:netzplan_planung} abgebildet}
\\
Aufgrund des entstandenen Quellcode Designs konnte die Entwicklung der einzelnen Klassen parallel ablaufen und nur die Klasse \glqq Messenger\grqq{} war davon abhängig,
dass die anderen Klassen bereits fertig gestellt waren. Entsprechend wurde die Entwicklung der Klassen \glqq VKeys\grqq , \glqq Radio\grqq{} und \glqq ColorChooser\grqq{}
zeitgleich eingeplant, wobei der Radio-Klasse die längste Dauer der Entwicklung eingeplant wurde. Jeder Klasse wurde außerdem eine Testphase, entsprechend ihrer erwarteten
Komplexität, eingeplant.
\\
Im Anschluss wurde die Messenger-Klasse mit dem größten zeitlichen Aufwand von 14 Stunden Entwicklung und 5 Stunden Testen eingeplant, da diese die Kommunikation
aller Komponenten sicherstellen soll.
\\
Abschließend wurden noch 5 Stunden für Tests des fertigen Systems und abschließendes Debuggen eingeplant, sowie das Schreiben dieser Dokumentation.\footnote{Alle bis hier 
beschriebenen Schritte sind in Kapitel~\ref{ch:diags} Abbildung~\ref{diag:netzplan_umsetzung} abgebildet}

\subsubsection{Arbeitsaufteilung}

\section{Durchführung}
Im Folgenden wird die Umsetzung des Projekts beschrieben. Alle im Text benannten Methoden finden sich in Kapitel~\ref{ch:codeschnipsel} unter dem jeweiligen Subkapitel
der Klasse, zu der die Methode gehört.
\subsection{Quellcode Design}



\section{Projektergebnis}
\subsection{Erreichte Ziele}


\subsection{Nicht erreichte Ziele und Gründe}


\subsection{Fazit}
\newpage
\section{Anlagen}
\subsection{Auflistung der Komponenten}
\begin{small}

\begin{table}[H]
    \caption{Benötigte Hardware}\label{tab:hardware}
    \begin{tabular}{|p{0.3\textwidth}|p{0.5\textwidth}|p{0.1\textwidth}|}
        \hline
        \textbf{Hardware} & \textbf{Aufgabe} & \textbf{Kosten}
        \\
        \hline\hline
        Arduino Mega 2560 
        & 
        \begin{itemize}
            \item Zentrale Schnittstelle aller Komponenten
            \item Verwaltung der Logik / Programmierbarkeit
            \item 
        \end{itemize} 
        & 
        2 x 21,99€
        \\
        \hline
        Elegoo Uno TFT Touchscreen 2,8''
        &
        \begin{itemize}
            \item Anzeige von Nachrichten
            \item Eingabe von Nachrichten
            \item User Interface
        \end{itemize}
        &
        2 x 19,99€
        \\
        \hline
        nRF24L01+ Wireless Transceiver Modul
        &
        \begin{itemize}
            \item Nachrichten Übertragen und Empfangen
            \item Überprüfung Verfügbarkeit anderer Geräte
        \end{itemize}
        &
        2 x 5,-€
        \\
        \hline
    \end{tabular}
\end{table}
\textbf{Gesamtkosten: 93.96€}. 
\\
Links zur genutzten Hardware sind in Kapitel~\ref{ch:hardwarelinks} aufgeführt.

\begin{table}[H]
    \caption{Benötigte Software}\label{tab:software}
    \begin{tabular}{|p{0.2\textwidth}|p{0.5\textwidth}|p{0.2\textwidth}|}
        \hline
        \textbf{Bibliothek} & \textbf{Aufgabe} & \textbf{Quelle}
        \\
        \hline\hline
        Elegoo\text{\_}GFX.h 
        & 
        Kern Grafikbibliothek des Elegoo Uno TFT Touchscreens. Ermöglicht das Drucken von Zeichen / Formen auf TFT Display.
        &
        Mitgeliefert auf CD bei TFT Touchscreen
        \\
        \hline
        Elegoo\text{\_}TFTLCD.h
        &
        Hardware-Bibliothek des Elegoo Uno TFT Touchscreens. Verantwortlich für die Kommunikation des Programms mit der Hardware.
        &
        Mitgeliefert auf CD bei TFT Touchscreen
        \\
        \hline
        TouchScreen.h
        &
        Bibliothek des Touchscreens des Elegoo Uno TFT Touchscreens. Erlaubt das erkennen von Berührungen des Touchscreens und die Lokalisierung der
        Berührung.
        &
        Mitgeliefert auf CD bei TFT Touchscreen
        \\
        \hline
        SPI.h
        &
        Erlaubt die Kommunikation des Programms mit dem SPI Bus des Arduino Board
        &
        In Arduino IDE inkludiert
        \\
        \hline
        nRF24L01.h
        &
        Hardware Bibliothek der nRF24L01+ Transceiver. Erlaubt Kommunikation des Moduls mit dem Arduino Board
        &
        Github %TODO die Quellen ALLE noch mal checken und anpassen
        \\
        \hline
        RF24.h
        &
        Programmierbare Schnittstelle der nRF24L01+ Transceiver. 
        &
        Github
        \\
        \hline
        Arduino.h
        &
        Liefert Kernfunktionen der Arduino Boards.
        &
        In Arduino IDE inkludiert
        \\
        \hline
    \end{tabular}
\end{table}
Links zur genutzten Software sind in Kapitel~\ref{ch:softwarelinks} aufgeführt.

\subsection{Diagramme}\label{ch:diags}
\begin{figure}[H]
    \begin{center}
        \includegraphics[scale=0.21]{Bilder/Netzplan.png}
        \caption{Netzplan des Projekts}\label{diag:netzplan}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale=0.4]{Bilder/netzplan_planung.png}
        \caption{Netzplan der Projektplanung}\label{diag:netzplan_planung}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale=0.35]{Bilder/netzplan_umsetzung.png}
        \caption{Netzplan der Projektumsetzung}\label{diag:netzplan_umsetzung}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includegraphics[scale=0.5]{Bilder/Class_Diagram.png}
        \caption{Klassendiagramm des Arduino Programms}\label{diag:classdiag}
    \end{center}
\end{figure}



\subsection{Bilder}


\newpage
\subsection{Git Repository und Quellcode Auszüge}\label{ch:codeschnipsel}
Das Repository mit dem gesamten Quellcode diesees Projektes befindet sich unter
\\
\url{https://github.com/LeichtMatrosee/TouchPager}
\\
Im Folgenden sind in der Dokumentation benannte Funktionen und Methoden angefügt.

\subsubsection{Klasse: Messenger}
\textbf{Konvertierung Touchscreen zu Screen Koordinaten}\label{code:screenparse}
\begin{lstlisting}
/**
 * @brief 
 * Parses Coordinates from touchpoint to screen coordinates
 * 
 * @param p TSPoint, Point the user touched on display
 * @return ScreenParse Struct containing parsed screen coordinates
 */
ScreenParse Messenger::parseCoords(TSPoint p) {
    ScreenParse parse;
    
    // Touch X: [120,940], Screen X: [0,240]
    // Parse X
    parse.x = (int) ((p.x - 120) / 3.5);

    // Touch Y: [70,920], Screen Y: [0,320]
    // Parse Y
    parse.y = (int) ((p.y - 70) / 2.66);
    return parse;
}
\end{lstlisting}

\subsubsection{Klasse: Radio}
\textbf{Empfangen von Nachrichten}\label{code:receive}
\begin{lstlisting}
/**
 * @brief 
 * Receives message from radio frequency
 * 
 * @return String received message or \0, if nothing was gotten
 */
String Radio::receiveMessage(void) {
    char buffer[128] = "";
    String msg = "";

    // Switch from sending to listening
    if (!_listening) switchState();

    // If no message is available, return universal break character
    if (!_antenna.available()) return "\0";
    Serial.println("Receiving: Antenna available");

    // Read available payload
    _antenna.read(&buffer, sizeof(buffer));

    // Convert payload (char array) to string for easier handling
    for (int i = 0; i < 128; i++) {
        msg += String(buffer[i]);
        if (buffer[i] == '\0') break;
    }

    Serial.println("Receiving: Received char Array: " + msg);

    return msg;
}
\end{lstlisting}

\begin{flushleft}\textbf{Wechsel zwischen senden und lauschen}\label{code:switch}\end{flushleft}
\begin{lstlisting}
/**
 * @brief 
 * Switches from listening to sending and the other way around
 * 
 */
void Radio::switchState() {
    byte _adress[6] = "00001";
    // Invert listening
    _listening = !_listening;

    // If listening: Prepare antenna for listening. Otherwise: Prepare antenna for sending
    if (_listening) {
        _antenna.openReadingPipe(_readingPipe, _adress);
        _antenna.startListening();
    } else {
        _antenna.stopListening();
        _antenna.openWritingPipe(_adress);
    }

    _antenna.setPALevel(_level);
}
\end{lstlisting}

\subsubsection{Klasse: VKeys}
\begin{flushleft}
    \textbf{Erkennung Tastatur Knopf}\label{code:keys}
\end{flushleft}
\begin{lstlisting}
/**
 * @brief 
 * Returns selected char by calculating, which column and row was pressed from passed x and y coords
 * 
 * @param x X coordinate from touchscreen selection
 * @param y Y coordinate from touchscreen selection
 * @return String Selected character parsed to a string, BACK if back button was selected and DONE, if done button was selected
 */
String VKeys::getCharFromCoords(int16_t x, int16_t y) {
    int row, column;

    // Complete Y: [70,920], range 850, keyboard [70,475], keyboard range of 405, 4 rows so 405/4 = 101.25
    if (y > 475) return String('\0');
    row = (int) ((y - 70)/ 101.25);

    // row 0 is spacebar, therefore return escaped space immediately, as nothing else is there.
    if (row == 0) {
        int tempX = (int)((x - 120) / 3.5);

        if (tempX < (_screen->width() / 4)) {
            return String("BACK");
        } else if (tempX > 3*(_screen->width() / 4)) {
            return String("DONE");
        }
        return String(" ");
    }

    if (row > 3) return String('2');

    // X Range ca. 120 - 920 for 10 columns, therefore 800 / 10 = 80
    column = (int) ((x - 120)/ 80);

    if (column < 11 && column >= 0 && row < 4 && row >0) return String(_special ? _specialChars[(3-row)][column] : _rows[(3-row)][column]);
    
    return String('-');
}
\end{lstlisting}

\subsubsection{Klasse: ColorChooser}
\textbf{Erkennen der ausgewählten Farbe}\label{code:color}
\begin{lstlisting}
/**
 * @brief 
 * Analyses coordinates passed into function and returns selected color
 * 
 * @param coords Coordinates of touchpoint, parsed to screen coordinates
 * @return uint16_t chosen Color or 0, if cancelled or -2, if selection was not valid
 */
uint16_t ColorChooser::getSelection(Coords coords) {
    int column, row;

    Serial.println("CC: X: " + String(coords.x) + ", Y: " + String(coords.y));

    // Check, if touchpoint is at height of cancel button
    if (320 - coords.y > 250) return 0;

    // If coordinates are out of valid ranges, return failure marker
    if (coords.x < 35 || coords.x > 215) return -2;
    if (coords.x < 135 && coords.x > 100) return -2;

    // If x is less than 100, it has to be first column (index 0), otherwise second column (index 1)
    column = coords.x < 100 ? 0 : 1;

    // Invert coordinates (320-y, because screen is 320 high) and divide by 60, because that's the 
    // height of the boxes, to get the row
    row = (int)((320 - coords.y) / 60);

    // Variable basically only exists, so that we don't try to reach indices the array does not have
    // This works, because the first column has indices 0,2,4,6 and second has 1,3,5,7
    int safeHandler = column + (row*2);

    // If selection > 7, set selection to failure, otherwise set selection to selected color
    uint16_t selection = (safeHandler > 7 ? -2 : _colors[safeHandler]);

    return selection;
}
\end{lstlisting}











\end{small}
\newpage
\section{Glossar}
\subsection{Technische Begriffe}
\textbf{Multithreading\label{def:multithreading}}
\\
Unter Multithreading versteht man in der Informatik den Prozess, ein Programm in mehrere Teilstränge aufzuteilen, die parallel 
ausgeführt werden.\footnote{Vgl. Internetquelle~\ref{itm:multithread}}
\subsection{Arduino Begriffe}
\textbf{Shield\label{def:shield}}
\\
Ein Shield ist ein Schaltplatte, die die Funtkionalität eines Arduinos erweitern kann und meistens so konzeptioniert ist, dass sie direkt in den Arduino gesteckt werden kann und diesen somit
zum Teil oder vollständig abdeckt.\footnote{Vgl. Internetquelle~\ref{itm:shield}}
\newpage
\section{Quellenverzeichnis}
\subsection{Internetquellen}
\begin{enumerate}
    \item Storage Insider: Was ist Multithreading - Online unter \url{https://www.storage-insider.de/was-ist-multithreading-a-1017586/} $\left[\text{07.01.2023}\right]$ \label{itm:multithread}
    \item Computer Hope: Arduino Shield - Online unter \url{} $\left[\text{07.01.2023}\right]$ \label{itm:shield}
\end{enumerate}

\subsection{Links genutzter Hardware}\label{ch:hardwarelinks}
\begin{enumerate}
    \item nRF24L01+ Transceiver: \url{}\label{itm:transceiverlink}
    \item Elegoo Arduino Mega R3: \url{}\label{itm:arduinolink}
    \item Elegoo TFT Touchscreen: \url{}\label{itm:tftlink}
\end{enumerate}

\subsection{Links genutzter Software}\label{ch:softwarelinks}
\begin{enumerate}
    \item RF24: Online unter \url{https://github.com/nRF24/RF24}\label{link:rf24}
\end{enumerate}

\end{document}